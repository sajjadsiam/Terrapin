#!/usr/bin/env python3
"""
Terrapin Vulnerability Verification Script
Checks if an SSH server is vulnerable to the Terrapin attack
"""

import socket
import struct
import sys
import argparse
import os


class VulnerabilityChecker:
    """
    Check SSH server for Terrapin vulnerability
    """
    
    # Vulnerable cipher suites
    VULNERABLE_CIPHERS = [
        b'chacha20-poly1305@openssh.com',
        b'aes128-cbc',
        b'aes192-cbc',
        b'aes256-cbc',
    ]
    
    # Vulnerable MAC algorithms (with encrypt-then-mac)
    VULNERABLE_MACS = [
        b'hmac-sha2-256-etm@openssh.com',
        b'hmac-sha2-512-etm@openssh.com',
        b'hmac-sha1-etm@openssh.com',
    ]
    
    def __init__(self, host: str, port: int, timeout: int = 10):
        """
        Initialize checker
        
        Args:
            host: Target hostname or IP
            port: Target port
            timeout: Connection timeout
        """
        self.host = host
        self.port = port
        self.timeout = timeout
        
        self.results = {
            'reachable': False,
            'ssh_version': None,
            'vulnerable_cipher': False,
            'vulnerable_mac': False,
            'ext_info_supported': False,
            'vulnerable': False,
            'ciphers': [],
            'macs': []
        }
    
    def check(self) -> dict:
        """
        Perform vulnerability check
        
        Returns:
            dict: Check results
        """
        print(f"[*] Checking {self.host}:{self.port}")
        print("-" * 60)
        
        try:
            # Connect to server
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((self.host, self.port))
            self.results['reachable'] = True
            print("[+] Server is reachable")
            
            # Read SSH banner
            banner = sock.recv(1024).decode().strip()
            self.results['ssh_version'] = banner
            print(f"[+] SSH Version: {banner}")
            
            # Send our banner
            client_banner = b"SSH-2.0-VulnCheck_1.0\r\n"
            sock.send(client_banner)
            
            # Send KEXINIT
            kexinit = self._build_kexinit()
            sock.send(kexinit)
            
            # Receive server KEXINIT
            server_kexinit = self._recv_packet(sock)
            
            if server_kexinit:
                # Parse KEXINIT
                self._parse_kexinit(server_kexinit)
                
                # Check for vulnerability
                self._assess_vulnerability()
            
            sock.close()
            
        except socket.timeout:
            print("[-] Connection timeout")
        except ConnectionRefusedError:
            print("[-] Connection refused")
        except Exception as e:
            print(f"[-] Error: {e}")
        
        return self.results
    
    def _build_kexinit(self) -> bytes:
        """Build KEXINIT packet"""
        cookie = os.urandom(16)
        
        # Algorithm lists
        kex_algs = b'curve25519-sha256,ecdh-sha2-nistp256'
        host_key_algs = b'ssh-ed25519,ssh-rsa'
        enc_algs = b'chacha20-poly1305@openssh.com,aes128-ctr'
        mac_algs = b'hmac-sha2-256'
        comp_algs = b'none'
        lang = b''
        
        # Build payload
        payload = struct.pack('B', 20)  # SSH_MSG_KEXINIT
        payload += cookie
        
        for alg_list in [kex_algs, host_key_algs, enc_algs, enc_algs,
                        mac_algs, mac_algs, comp_algs, comp_algs,
                        lang, lang]:
            payload += struct.pack('>I', len(alg_list))
            payload += alg_list
        
        payload += b'\x00\x00\x00\x00\x00'  # first_kex_packet_follows + reserved
        
        # Add padding
        padding_length = 8 - ((len(payload) + 5) % 8)
        if padding_length < 4:
            padding_length += 8
        
        padding = os.urandom(padding_length)
        
        # Build packet
        packet_length = len(payload) + padding_length + 1
        packet = struct.pack('>I', packet_length)
        packet += struct.pack('B', padding_length)
        packet += payload
        packet += padding
        
        return packet
    
    def _recv_packet(self, sock: socket.socket) -> bytes:
        """Receive SSH packet"""
        try:
            length_data = sock.recv(4)
            if len(length_data) < 4:
                return b''
            
            packet_length = struct.unpack('>I', length_data)[0]
            packet_data = sock.recv(packet_length)
            
            return length_data + packet_data
        except Exception:
            return b''
    
    def _parse_kexinit(self, packet: bytes):
        """Parse KEXINIT packet"""
        try:
            offset = 6  # Skip length and padding length
            offset += 17  # Skip message type and cookie
            
            # Parse 10 algorithm lists
            alg_names = ['kex', 'host_key', 'enc_c2s', 'enc_s2c',
                        'mac_c2s', 'mac_s2c', 'comp_c2s', 'comp_s2c',
                        'lang_c2s', 'lang_s2c']
            
            for i, name in enumerate(alg_names):
                if offset + 4 > len(packet):
                    break
                
                list_length = struct.unpack('>I', packet[offset:offset+4])[0]
                offset += 4
                
                if offset + list_length > len(packet):
                    break
                
                alg_list = packet[offset:offset+list_length]
                offset += list_length
                
                # Check encryption algorithms
                if name in ['enc_c2s', 'enc_s2c']:
                    ciphers = alg_list.split(b',')
                    self.results['ciphers'].extend([c.decode() for c in ciphers])
                    
                    for vuln_cipher in self.VULNERABLE_CIPHERS:
                        if vuln_cipher in alg_list:
                            self.results['vulnerable_cipher'] = True
                
                # Check MAC algorithms
                if name in ['mac_c2s', 'mac_s2c']:
                    macs = alg_list.split(b',')
                    self.results['macs'].extend([m.decode() for m in macs])
                    
                    for vuln_mac in self.VULNERABLE_MACS:
                        if vuln_mac in alg_list:
                            self.results['vulnerable_mac'] = True
                
                # Check for ext-info support
                if name == 'kex':
                    if b'ext-info-s' in alg_list or b'ext-info-c' in alg_list:
                        self.results['ext_info_supported'] = True
        
        except Exception as e:
            print(f"[!] Error parsing KEXINIT: {e}")
    
    def _assess_vulnerability(self):
        """Assess overall vulnerability"""
        # Server is vulnerable if:
        # 1. Supports vulnerable cipher OR (vulnerable MAC with CBC)
        # 2. Supports ext-info
        
        self.results['vulnerable'] = (
            self.results['vulnerable_cipher'] and
            self.results['ext_info_supported']
        )
    
    def print_report(self):
        """Print vulnerability report"""
        print("\n" + "=" * 60)
        print("VULNERABILITY REPORT")
        print("=" * 60)
        print(f"Target: {self.host}:{self.port}")
        print(f"Reachable: {self.results['reachable']}")
        
        if not self.results['reachable']:
            print("\n‚ùå Server is not reachable")
            return
        
        print(f"SSH Version: {self.results['ssh_version']}")
        print()
        
        # Cipher check
        print("Encryption Algorithms:")
        if self.results['ciphers']:
            for cipher in set(self.results['ciphers']):
                vulnerable = any(vc.decode() in cipher for vc in self.VULNERABLE_CIPHERS)
                marker = "‚ö†Ô∏è  VULNERABLE" if vulnerable else "‚úì"
                print(f"  {marker} {cipher}")
        else:
            print("  (none detected)")
        print()
        
        # MAC check
        print("MAC Algorithms:")
        if self.results['macs']:
            for mac in set(self.results['macs']):
                vulnerable = any(vm.decode() in mac for vm in self.VULNERABLE_MACS)
                marker = "‚ö†Ô∏è  VULNERABLE" if vulnerable else "‚úì"
                print(f"  {marker} {mac}")
        else:
            print("  (none detected)")
        print()
        
        # Extension support
        ext_marker = "‚úì" if self.results['ext_info_supported'] else "‚úó"
        print(f"{ext_marker} Extension Info (ext-info): {self.results['ext_info_supported']}")
        print()
        
        # Overall assessment
        print("=" * 60)
        if self.results['vulnerable']:
            print("üéØ VERDICT: VULNERABLE to Terrapin Attack (CVE-2023-48795)")
            print()
            print("This server is vulnerable to the Terrapin attack because:")
            print("  ‚úì Supports vulnerable cipher suite")
            print("  ‚úì Supports SSH extension info")
            print()
            print("An attacker in a MITM position could:")
            print("  - Drop SSH_MSG_EXT_INFO packets")
            print("  - Downgrade security features")
            print("  - Potentially perform other attacks")
        else:
            print("‚úÖ VERDICT: NOT VULNERABLE")
            print()
            if not self.results['vulnerable_cipher']:
                print("  ‚úì No vulnerable ciphers enabled")
            if not self.results['ext_info_supported']:
                print("  ‚úì Extension info not supported")
        
        print("=" * 60)
        print()


def main():
    parser = argparse.ArgumentParser(
        description='Terrapin Attack Vulnerability Checker (CVE-2023-48795)',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('--host', required=True,
                       help='Target SSH server hostname or IP')
    parser.add_argument('--port', type=int, default=22,
                       help='Target SSH server port (default: 22)')
    parser.add_argument('--timeout', type=int, default=10,
                       help='Connection timeout in seconds (default: 10)')
    parser.add_argument('--json', action='store_true',
                       help='Output results in JSON format')
    
    args = parser.parse_args()
    
    # Create checker
    checker = VulnerabilityChecker(args.host, args.port, args.timeout)
    
    # Run check
    results = checker.check()
    
    # Print report
    if args.json:
        import json
        print(json.dumps(results, indent=2))
    else:
        checker.print_report()
    
    # Exit code
    if results['vulnerable']:
        return 1
    return 0


if __name__ == '__main__':
    sys.exit(main())
